<?php

use \WP_CLI\Utils;

class VIP_Go_Migrations_Command extends WPCOM_VIP_CLI_Command {

	/**
	 * Run dbDelta() for the current site.
	 *
	 * [--network]
	 * : Update databases for all sites on a network
	 *
	 * [--dry-run]
	 * : Show changes without updating
	 *
	 * ## OPTIONS
	 *
	 * [<tables>]
	 * : Which tables to update (all, blog, global, ms_global, "")
	 * ---
	 * default: ""
	 * options:
	 *   - all
	 *   - blog
	 *   - global
	 *   - ms_global
	 *   - ""
	 */
	function dbdelta( $args, $assoc_args ) {
		global $wpdb;

		$tables = isset( $args[1] ) ? $args[1] : '';

		$network = Utils\get_flag_value( $assoc_args, 'network' );
		if ( $network && ! is_multisite() ) {
			WP_CLI::warning( 'This is not a multisite install. Proceeding as single site.' );
			$network = false;
		}

		$dry_run = Utils\get_flag_value( $assoc_args, 'dry-run' );
		if ( $dry_run ) {
			WP_CLI::log( 'Performing a dry run, with no database modification.' );
		}

		if ( $network ) {
			$iterator_args = array(
				'table' => $wpdb->blogs,
				'where' => array( 'spam' => 0, 'deleted' => 0, 'archived' => 0 ),
			);
			$it = new \WP_CLI\Iterators\Table( $iterator_args );
			foreach ( $it as $blog ) {
				$url = $blog->domain . $blog->path;
				$cmd = "--url={$url} vip migration dbdelta";

				// Update global tables if this is the main site
				// otherwise only update the given blog's tables
				if ( is_main_site( $blog->blog_id ) ) {
					$cmd .= ' all';
				} else {
					$cmd .= ' blog';
				}

				if ( $dry_run ) {
					$cmd .= ' --dry-run';
				}

				WP_CLI::line();
				WP_CLI::line( WP_CLI::colorize( '%mUpdating:%n ' ) . $blog->domain . $blog->path );
				WP_CLI::runcommand( $cmd );
			}
			return;
		}

		require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );

		$changes = dbDelta( $tables, ! $dry_run );
		
		if ( empty( $changes ) ) {
			WP_CLI::success( 'No changes.' );
			return;
		}

		foreach ( $changes as $change ) {
			WP_CLI::line( $change );
		}

		$count = count( $changes );
		WP_CLI::success( _n( '%s change', '%s changes', $count ), number_format_i18n( $count ) );
	}

	/**
	 * Iterate over attachments and check to see if they actually exist.
	 *
	 * @subcommand validate-attachments
	 * @synopsis <csv-filename> [--log-found-files]
	 */
	public function validate_attachments( $args, $assoc_args ) {
		$log_found_files = WP_CLI\Utils\get_flag_value( $assoc_args, 'log-found-files', false );
		$output_file = $args[0];

		$offset = 0;
		$limit = 500;
		$output = array();

		$attachment_count = array_sum( (array) wp_count_posts( 'attachment' ) );
		$progress = \WP_CLI\Utils\make_progress_bar( 'Checking ' . number_format( $attachment_count ) . ' attachments', $attachment_count );

		$file_descriptor = fopen( $output_file, 'w' );
		if ( false === $file_descriptor ) {
			WP_CLI::error( sprintf( 'Cannot open file for writing: %s', $filename ) );
		}

		global $wpdb;
		do {
			$sql = $wpdb->prepare( 'SELECT guid FROM ' . $wpdb->posts . ' WHERE post_type = "attachment" LIMIT %d,%d', $offset, $limit );
			$attachments = $wpdb->get_results( $sql );

			foreach ( $attachments as $attachment ) {
				$log_request = false;
				$url = $attachment->guid;

				/*
				 * TODO: Switch over to `curl_multi` to do lookups in parallel
				 * if this turns out to be too slow for large media libraries.
				 */
				$request = wp_remote_head( $url );
				$response_code = wp_remote_retrieve_response_code( $request );
				$response_message = wp_remote_retrieve_response_message( $request );

				if ( 200 === $response_code ) {
					$log_request = $log_found_files;
				} else {
					$log_request = true;
				}

				if ( $log_request ) {
					$output[] = array(
						$url,
						$response_code,
						$response_message,
					);
				}

				$progress->tick();
			}

			// Pause.
			sleep( 1 );

			$offset += $limit;
		} while ( count( $attachments ) );
		$progress->finish();
		WP_CLI\Utils\write_csv( $file_descriptor, $output );
		fclose( $file_descriptor );
	}

	/**
	 * Import user meta attributes from a CSV file.
	 *
	 * The CSV file is headerless with the following structure:
	 *
	 * ```
	 * user_key,meta_key,meta_value stored in JSON
	 * ```
	 *
	 * Example:
	 *
	 * ```
	 * jsmith,user_profile,"{""title"":""editorial assistant"",""bio"":""John Smith is an editorial assistant at BigNewsCo.""}"
	 * ```
	 *
	 * In 99.999% of cases, this CSV file will be generated by a WP.com CLI command: `wp vip-export user-attributes`
	 *
	 * ## OPTIONS
	 *
	 * <file>
	 * : The CSV file to import from.
	 *
	 * [--user_key=<userlogin>]
	 * : The `user_key` is the "key" used to uniquely identify a user, a property of the `WP_User` object.  Can be one of the following: ID, user_nicename, user_email, user_login. Defaults to user_login.
	 *
	 * [--dry-run=<true>]
	 * : Do a "dry run" and no data modification will be done.  Defaults to true.
	 *
	 * ## EXAMPLES
	 *
	 *     # Imports user meta from the example "usermeta.csv" file with the default user key.
	 *     $ wp vip migration import-user-meta usermeta.csv --dry-run=false
	 *
	 *     # Does a "dry run" import from "usermeta.csv" with the "user_email" user key.
	 *     $ wp vip migration import-user-meta usermeta.csv --user_key=user_email
	 *
	 * @subcommand import-user-meta
	 */
	function import_user_meta( $args, $assoc_args ) {
		$filename = $args[0];
		$user_key = $assoc_args['user_key'] ?? 'user_login';
		$dry_run = Utils\get_flag_value( $assoc_args, 'dry-run', true );

		// Force a boolean, always default to true.
		$dry_run = filter_var( $dry_run, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE ) ?? true;

		if ( $dry_run ) {
			WP_CLI::log( 'Performing a dry run, with no database modification.' );
		}

		if ( ! file_exists( $filename ) ) {
			WP_CLI::error( sprintf( 'Missing file: %s', $filename ) );
		}

		foreach ( new \WP_CLI\Iterators\CSV( $filename ) as $user_data ) {
			$user_data = array_values( $user_data ); // Strip useless array keys.
			list( $user_value, $meta_key, $meta_value ) = $user_data;

			$meta_value = json_decode( $meta_value, true );

			switch ( $user_key ) {
				case 'ID':
					$user = get_user_by( 'ID', $user_value );
					break;
				case 'user_nicename':
					$user = get_user_by( 'slug', $user_value );
					break;
				case 'user_email':
					$user = get_user_by( 'email', $user_value );
					break;
				case 'user_login':
					$user = get_user_by( 'login', $user_value );
					break;
				default:
					WP_CLI::warning( 'Error getting user ' . $user_value );
			}

			if ( ! $dry_run ) {
				// Live run
				$add_meta = update_user_meta( $user->ID, $meta_key, $meta_value );
				if ( false !== $add_meta ) {
					WP_CLI::line( 'Meta ' . $meta_key . ' added to user ' . $user_value );
				} else {
					WP_CLI::warning( 'Meta ' . $meta_key . ' NOT added to user ' . $user_value );
				}
			} else {
				// Dry Run
				WP_CLI::line( '[DRY-RUN] Meta ' . $meta_key . ' added to user ' . $user_value );
			}
		}
	}
	
	/**
	 * Clones a site to another site.
	 *
	 * "Cloning" is a misleading term here.  All of the actual cloning needs to be done outside this program
	 * by copying the SQL from one site to another.  For VIP Go, this can be done using the `vip-cli` tool.
	 *
	 * ## OPTIONS
	 *
	 * <old-domain>
	 * : The old domain.
	 *
	 * <new-domain>
	 * : The new domain.
	 *
	 * [--dry-run=<true>]
	 * : Do a "dry run" and no data modification will be done.  Defaults to true.
	 *
	 * ## EXAMPLES
	 *
	 *     # Converts the data from the parent site www.example.com to the child site preprod.example.com
	 *     $ wp vip migration clone www.example.com preprod.example.com --dry-run=false
	 *
	 *     # Does a "dry run" convert from "www.example.com" to "preprod.example.com"
	 *     $ wp --allow-root vip migration clone www.example.com preprod.example.com
	 *
	 * @subcommand clone
	*/
	public function clone( $args, $assoc_args ) {
		$old_domain = $args[0];
		$new_domain = $args[1];
		$dry_run = Utils\get_flag_value( $assoc_args, 'dry-run', true );

		// Force a boolean, always default to true.
		$dry_run = filter_var( $dry_run, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE ) ?? true;

		// Disable object caching.  It can get really messed up with all of this.
		if ( ! $dry_run ) {
			// Make sure we start with a clean cache.
			wp_cache_flush();
			wp_suspend_cache_addition( true );
			WP_CLI::log( 'Cleared cache and Disabled object caching' );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have cleared cache and disabled object caching' );
		}

		// Delete JPOP options
		if ( ! $dry_run ) {
			WP_CLI::log( 'Deleting JPOP options' );
			delete_option( 'jetpack_options' );
			delete_option( 'jetpack_private_options' );
			delete_option( 'vaultpress' );
			delete_option( 'vaultpress_auto_register' );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have deleted JPOP options' );
		}

		// Do the search-replace
		$options = array(
			'verbose',
			'allow-root',
		);
		$command = sprintf( 'search-replace %s %s "wp_*" --url=%s', $old_domain, $new_domain, $new_domain );
		if ( ! $dry_run ) {
			WP_CLI::log( 'Running ' . $command );
			$search_replace = WP_CLI::runcommand( $command, $options );
			WP_CLI::log( $search_replace );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have ran: ' . $command );
		}

		// Re-enable object caching
		if ( ! $dry_run ) {
				WP_CLI::log( 'Re-enabled object caching' );
				wp_suspend_cache_addition( false );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have re-enabled object caching' );
		}

		// Flush the cache.
		$options = array(
			'allow-root',
		);
		if ( ! $dry_run ) {
			wp_cache_flush();
			WP_CLI::log( 'Flushing cache' );
			$cache_flush = WP_CLI::runcommand( 'cache flush --url=' . $new_domain, $options );
			WP_CLI::log( $cache_flush );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have flushed cache' );
		}

		// Delete any transients that may have happened while objecg caching was off.
		$options = array(
			'allow-root',
		);
		if ( ! $dry_run ) {
			$transient_delete = WP_CLI::runcommand( 'transient delete-all --url=' . $new_domain, $options );
			WP_CLI::log( $transient_delete );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have delete transients' );
		}

		// Connect Jetpack.
		$options = array(
			'allow-root',
		);
		if ( ! $dry_run ) {
			WP_CLI::log( 'Running Jetpack Start for ' . get_site_url() );
			$jetpack_start = WP_CLI::runcommand( 'jetpack-start connect --url=' . get_site_url() , $options );
			WP_CLI::log( $jetpack_start );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have ran Jetpack Start for ' . get_site_url() );
		}
	}

	/**
	 * Clones a multisite to another multisite.
	 *
	 * "Cloning" is a misleading term here.  All of the actual cloning needs to be done outside this program
	 * by copying the SQL from one site to another.  For VIP Go, this can be done using the `vip-cli` tool.
	 *
	 * ## OPTIONS
	 *
	 * <old-domain>
	 * : The old domain.
	 *
	 * <new-domain>
	 * : The new domain.
	 *
	 * [--dry-run=<true>]
	 * : Do a "dry run" and no data modification will be done.  Defaults to true.
	 *
	 * ## EXAMPLES
	 *
	 *     # Converts the data from the parent site test-subdir-ms-01.go-vip.co data to the child site test-subdir-ms-01-preprod.go-vip.co
	 *     $ wp vip migration clone-ms test-subdir-ms-01.go-vip.co test-subdir-ms-01-preprod.go-vip.co --url=test-subdir-ms-01.go-vip.co --dry-run=false
	 *
	 *     # Does a "dry run" convert from "www.example.com" to "preprod.example.com"
	 *     $ wp --allow-root vip migration clone-ms www.example.com preprod.example.com --url=www.example.com
	 *
	 * @subcommand clone-ms
	*/
	public function clone_ms( $args, $assoc_args ) {
		$old_domain = $args[0];
		$new_domain = $args[1];
		$dry_run = Utils\get_flag_value( $assoc_args, 'dry-run', true );

		// Force a boolean, always default to true.
		$dry_run = filter_var( $dry_run, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE ) ?? true;

		// Disable object caching.  It can get really messed up with all of this.
		if ( ! $dry_run ) {
			// Make sure we start with a clean cache.
			wp_cache_flush();
			wp_suspend_cache_addition( true );
			WP_CLI::log( 'Cleared cache and Disabled object caching' );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have cleared cache and disabled object caching' );
		}

		// Delete JPOP options
		if ( ! $dry_run ) {
			WP_CLI::log( 'Deleting JPOP options' );
			delete_option( 'jetpack_options' );
			delete_option( 'jetpack_private_options' );
			delete_option( 'vaultpress' );
			delete_option( 'vaultpress_auto_register' );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have deleted JPOP options' );
		}

		// Get a list of Blog IDs from the database.
		global $wpdb;
		$sites = $wpdb->get_results( 'SELECT blog_id FROM ' . $wpdb->blogs, ARRAY_A );

		// Change site domains in database.
		foreach ( $sites as $site ) {
			$site_id = (int) $site['blog_id'];
			if ( ! $dry_run ) {
				WP_CLI::log( 'Running ' . sprintf( 'UPDATE ' . $wpdb->blogs . ' SET domain = %s WHERE blog_id = %d', $new_domain, $site_id ) );
				if ( false !== $wpdb->query( $wpdb->prepare( 'UPDATE ' . $wpdb->blogs . ' SET domain = %s WHERE blog_id = %d', $new_domain, $site_id ) ) ) {
					WP_CLI::log( 'Site ' . $site_id . ' updated to ' . $new_domain );
				} else {
					WP_CLI::warning( 'Site ' . $site_id . ' NOT updated to ' . $new_domain );
				}
			} else {
				WP_CLI::log( '[DRY-RUN] Would have ran: ' . sprintf( 'UPDATE ' . $wpdb->blogs . ' SET domain = %s WHERE blog_id = %d', $new_domain, $site_id ) );
			}
		}

		// Change network domains in database.
		// TODO: Iterate over multiple networks.  It's rare, but possible there will be multiple networks.
		if ( ! $dry_run ) {
			if ( false !== $wpdb->query( $wpdb->prepare( 'UPDATE ' . $wpdb->site . ' SET domain = %s WHERE id = %d', $new_domain, 1 ) ) ) {
				WP_CLI::log( 'Network ' . 1 . ' updated to ' . $new_domain );
			} else {
				WP_CLI::warning( 'Network ' . 1 . ' NOT updated to ' . $new_domain );
			}
		} else {
			WP_CLI::log( '[DRY-RUN] Would have ran: ' . sprintf( 'UPDATE ' . $wpdb->site . ' SET domain = %s WHERE id = %d', $new_domain, 1 ) );
		}

		// I don't remember why this is here?  I'll need to test removing it.
		wp_cache_flush();

		// Do the search-replace on site content.
		foreach ( $sites as $site ) {
			$site_id = (int) $site['blog_id'];

			$options = array(
				'verbose',
				'allow-root',
			);
			$command = sprintf( 'search-replace %s %s "wp_%d_*" --url=%s', $old_domain, $new_domain, $site_id, $new_domain );
			if ( ! $dry_run ) {
				// We don't need this for site 1.
				if ( 1 !== $site_id ) {
					WP_CLI::log( 'Running ' . $command );
					$search_replace = WP_CLI::runcommand( $command, $options );
					WP_CLI::log( $search_replace );
				}
			} else {
				WP_CLI::log( '[DRY-RUN] Would have ran: ' . $command );
			}
		}

		// Do the search-replace for the network.
		$options = array(
			'verbose',
			'allow-root',
		);
		$command = sprintf( 'search-replace %s %s "wp_*" --url=%s', $old_domain, $new_domain, $new_domain );
		if ( ! $dry_run ) {
			WP_CLI::log( 'Running ' . $command );
			$search_replace = WP_CLI::runcommand( $command, $options );
			WP_CLI::log( $search_replace );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have ran: ' . $command );
		}

		// Re-enable object caching
		if ( ! $dry_run ) {
				WP_CLI::log( 'Re-enabled object caching' );
				wp_suspend_cache_addition( false );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have re-enabled object caching' );
		}

		// Flush the cache.
		$options = array(
			'allow-root',
		);
		if ( ! $dry_run ) {
			wp_cache_flush();
			WP_CLI::log( 'Flushing cache' );
			$cache_flush = WP_CLI::runcommand( 'cache flush --url=' . $new_domain, $options );
			WP_CLI::log( $cache_flush );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have flushed cache' );
		}

		// Delete any transients that may have happened while objecg caching was off.
		$options = array(
			'allow-root',
		);
		if ( ! $dry_run ) {
			$transient_delete = WP_CLI::runcommand( 'transient delete-all --url=' . $new_domain, $options );
			WP_CLI::log( $transient_delete );
		} else {
			WP_CLI::log( '[DRY-RUN] Would have delete transients' );
		}

		// Connect Jetpack.
		foreach ( $sites as $site ) {
			$site_id = (int) $site['blog_id'];
			$options = array(
				'allow-root',
			);
			if ( ! $dry_run ) {
				WP_CLI::log( 'Running Jetpack Start for ' . get_site_url( $site_id ) );
				$jetpack_start = WP_CLI::runcommand( 'jetpack-start connect --url=' . get_site_url( $site_id ) , $options );
				WP_CLI::log( $jetpack_start );
			} else {
				WP_CLI::log( '[DRY-RUN] Would have ran Jetpack Start for ' . get_site_url( $site_id ) );
			}
		}
	}

}

WP_CLI::add_command( 'vip migration', 'VIP_Go_Migrations_Command' );
